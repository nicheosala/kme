"""This is the only file allowed to communicate with the Quantum Channel."""
from asyncio import Queue, QueueEmpty
from dataclasses import dataclass
from uuid import UUID

from kme.encoder import dump, load
from kme.model.errors import KeyNotFound
from kme.utils import bit_length, collecitonint_to_b64
from qcs import interface as qci
from qcs.orm import Block


@dataclass(frozen=True, slots=True)
class BlockLeftover:
    """Leftover of the last block generated by the qcs.

    The last requested block may not be completely exploited by a call to
    generate_key_material(). Therefore, there exists this leftover. It may be
    exploited by following calls to generate_key_material().

    This allows not to waste any random bit generated by the quantum channel.

    Moreover, if the quantum channel produces blocks containing a number of bits
    greater than the commonly requested key bitlength, this reduces the number of
    calls to the quantum channel, improving overall performance.
    """

    block: Block
    starting_from: int


@dataclass(frozen=True, slots=True)
class Instruction:
    """An instruction on how to retrieve key material from a block.

    'start' and 'end' works like for function range(): 'start' is included,
    'end' excluded.
    """

    block_id: UUID
    start: int
    end: int


lefts: Queue[BlockLeftover] = Queue()


def get_randbits_from_local_storage(
    req_bitlength: int,
) -> tuple[list[int], list[Instruction]]:
    """Ask the local storage for random bits."""
    key_material: list[int] = []
    instructions: list[Instruction] = []

    while (diff := req_bitlength - bit_length(key_material)) > 0:
        try:
            left = lefts.get_nowait()
        except QueueEmpty:
            return key_material, instructions

        b, start = left.block, left.starting_from

        if bit_length(b.key) > diff:
            end = start + diff // 8
            lefts.put_nowait(BlockLeftover(b, end))
        else:
            end = len(b.key)

        instructions.append(Instruction(b.id, start, end))
        key_material.extend(b.key[start:end])

    return key_material, instructions


async def get_randbits_from_quantum_channel(
    req_bitlength: int, key_material: list[int], instructions: list[Instruction]
) -> tuple[list[int], list[Instruction]]:
    """Ask the quantum channel for new blocks.

    If kme does not have a sufficient number of random bits locally, it is forced to
    communicate with the quantum channel, asking for such bits.
    """
    while (diff := req_bitlength - bit_length(key_material)) > 0:
        try:
            b = await qci.gen_block()
        except qci.BlockNotGenerated:
            raise KeyNotFound()

        if bit_length(b.key) > diff:
            end = diff // 8
            lefts.put_nowait(BlockLeftover(b, end))
        else:
            end = len(b.key)

        instructions.append(Instruction(b.id, 0, end))
        key_material.extend(b.key[:end])

    return key_material, instructions


async def generate_key_material(req_bitlength: int) -> tuple[str, object]:
    """
    Return key_material encoded as a base64 string, with the 'req_bitlength'
    requested. Alongside the key material, the instructions to re-build it,
    given the exploited blocks, is returned. These instructions have to be
    stored inside the database shared between communicating KMEs.
    """
    assert req_bitlength % 8 == 0

    key_material, instructions = get_randbits_from_local_storage(req_bitlength)

    if bit_length(key_material) < req_bitlength:
        key_material, instructions = await get_randbits_from_quantum_channel(
            req_bitlength, key_material, instructions
        )

    return collecitonint_to_b64(key_material), dump(instructions)


async def retrieve_key_material(json_instructions: object) -> str:
    """
    Return the key material re-created based on the given instructions.
    """
    key_material_ints: list[int] = []

    instructions: tuple[Instruction, ...] = load(
        json_instructions, tuple[Instruction, ...]
    )

    for i in instructions:
        try:
            b = await qci.get_block_by_id(i.block_id)
        except qci.BlockNotFound:
            raise KeyNotFound()

        key_material_ints.extend(b.key[i.start : i.end])

    return collecitonint_to_b64(key_material_ints)
